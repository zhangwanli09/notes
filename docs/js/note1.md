# js运行机制（Event Loop）

### 单线程

JavaScript是单线程的，也就是同一时间只能做一件事。这是js的核心特征。

为什么不是多线程？js的主要用途是处理交互操作DOM，这决定了它只能是单线程，否则会带来复杂的同步问题。（假定js同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？）。

### 任务队列

单线程意味着所有任务需要`排队`，前一个任务结束才会执行下一个任务。如果前一个任务耗时很长，下一个任务就必须等着。很多时候CPU是闲着的，因为IO设备很慢（比如Ajax请求），不得不等结果出来，再往下执行。

JavaScript是如何处理以上问题的？主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

将任务分成两种：
1. `同步任务`：在主线程排队执行的任务，前一个任务执行完毕，才能执行后一个任务。
2. `异步任务`：不进入主线程，而进入`任务队列`的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

异步任务的运行机制，是基于`事件循环`，事件循环大致有以下几个步骤：
1. 所有同步任务都在主线程上执行，形成一个`执行栈`。
2. 主线程之外，存在一个`任务队列`，当异步任务`有结果`，就会在任务队列中放置一个`事件`。
3. 一旦`执行栈`中所有同步任务`执行完毕`，系统就会读取`任务队列`，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. 主线程不断`重复`上面的第3步。

![主线程和任务队列](../imgs/img4.png ':size=500')

只要主线程空了，就会去读取`任务队列`，这个过程会不断重复。这就是JavaScript的运行机制。

任务队列（事件的队列），每完成一个异步任务就会在任务队列中添加一个事件，表示相关的异步任务可以进入执行栈。主线程读取任务队列，就是读取里面有哪些事件。任务队列中的事件也包括一些用户产生的事件（点击事件，页面滚动事件等）。只要指定过回调函数，这些事件发生时就会进入任务队列，等待主线程读取。

回调函数就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

任务队列是一个先进先出的数据结构，排在前面的事件优先被主线程读取。主线程的读取基本上是自动的，只要执行栈一清空，任务队列上第一位事件就会自动进入主线程。由于可能存在定时器（setTimeout，setInterval）功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

### Event Loop

主线程（js引擎线程）从任务队列中读取事件的过程是循环不断的，这种运行机制称为`Event Loop`（事件循环）。

一旦执行栈中所有同步任务执行完毕（也就是js引擎线程空闲了），系统就会读取任务队列，将可运行的异步任务添加到执行栈中执行。（只要任务队列中有事件回调，就说明可以执行）。

执行栈中的代码（同步任务），总是在任务队列（异步任务）之前执行。

![Event Loop](../imgs/img3.png ':size=500')

### 宏任务（macro task）、微任务（micro task）
