# TCP 连接

在真正的读写操作之前，server 与 client 之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时，它们可以释放这个连接，连接的`建立`是需要`3 次握手`，而`释放`则需要`4 次挥手`，所以每次连接都需要消耗资源和时间。

TCP 属于`传输层`，提供可靠的字节流服务。

1. 字节流服务。将大块的数据`分割`成以报文段为单位的`数据包`进行管理。
2. 传输服务。把数据`准确`可靠的传输给对方。

TCP 协议为了更容易传送大数据才把数据分割，且能够确认数据最终是否送达到对方（三次握手）。

## 三次握手

握手过程使用 TCP 的标志：`SYN`（synchronize）和`ACK`（acknowledgement）：

1. 客户端发送一个带`SYN`标志的数据包给服务器。此时客户端处于`SYN_SENT`（同步已发送）状态。
2. 服务器收到后，回传一个带有`SYN/ACK`标志的数据包给客户端。此时服务器处于`SYN_RCVD`（同步收到）状态。
3. 客户端再回传一个带`ACK`标志的数据包给服务器。握手结束。此时客户端和服务器都处于`ESTABLISHED`（已建立连接）状态。

![三次握手](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA1MTEwNDA1NjY2?x-oss-process=image/format,png ':size=700')

为什么还要`第三次握手`：为了防止失效的连接请求传到服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

## 四次挥手

1. 客户端设置 seq 和 ACK，向服务器发送一个`FIN`（终结）报文段。此时客户端进入`FIN_WAIT_1`状态，表示客户端没有数据要发送给服务端了。
2. 服务端收到了客户端发送的 FIN 报文段，向客户端回复一个`ACK`报文段。
3. 服务端向客户端发送`FIN`报文段，请求关闭连接，同时服务端进入`LAST_ACK`状态。
4. 客户端收到服务端发送的 FIN 报文段后，向服务端发送`ACK`报文段，然后客户端进入`TIME_WAIT`状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时客户端等待`2MSL`（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。

![四次挥手](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjA2MDg0ODUxMjcy?x-oss-process=image/format,png ':size=700')

为什么要四次挥手：

客户端发送 FIN 连接释放报文之后，服务器收到这个报文，就进入 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

> [参考](https://blog.csdn.net/qzcsu/article/details/72861891)
