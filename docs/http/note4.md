# HTTP 缓存

通过复用已获取的资源，可以显著提高网站性能，减少等待时间和流量，缓解服务器压力。

缓存是一种保存`资源副本`并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

缓存需要`合理`配置，并不是所有资源都永久不变，对一个资源的缓存应截止到其下一次发生改变（不能缓存过期的资源）。

## 缓存的种类

可大致分为两类：

1. `私有`缓存。只能用于`单独`用户。
2. `共享`缓存。能够被`多个`用户使用。

浏览器缓存（`私有`）拥有用户通过HTTP下载的所有文档。为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余请求。可以提供缓存内容的离线浏览。

代理缓存（`共享`）。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

## 缓存的目标

常见份HTTP缓存只能存储`GET`响应。普通的缓存案例：

1. `GET`请求的成功响应（200）。
2. 永久重定向（301）。
3. 错误响应（404）
4. 不完全的响应（206），只返回局部信息。
5. 除了 GET 请求外，如果匹配到作为一个已被定义的`cache`键名的响应。

## 缓存控制

通过 [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) 头（HTTP/1.1定义）来定义`缓存策略`。请求头和响应头都支持这个属性。

1. `no-store`：没有缓存。缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
2. `no-cache`：缓存但重新验证。请求发出时，缓存会将此请求`发到服务器`（该请求会`带有`与本地缓存相关的`验证字段`），服务器端会`验证`请求中所描述的缓存`是否过期`，若未过期（实际就是返回`304`），则缓存才使用本地缓存副本。
3. `public`：公共缓存。响应可以被任何中间人（中间代理、CDN等）缓存。若指定了 public，则一些通常不被中间人缓存的页面（默认是 private），比如带有HTTP验证信息（帐号密码）的页面或某些特定状态码的页面，将会被其缓存。
4. `private`：私有缓存。响应是专用于某单个用户的，中间人不能缓存。
5. `max-age=<seconds>`：过期。表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。
6. `must-revalidate`：验证方式。必须先`验证`它的状态，已过期的缓存将不被使用。

```
不使用缓存
Cache-Control: no-store

缓存，但需要向服务器重新验证是否过期
Cache-Control: no-cache

公共缓存 中间人可缓存
Cache-Control: public

私有缓存（默认） 中间人不能缓存
Cache-Control: private

设置最大过期时间
Cache-Control: max-age=31536000

先验证状态，已过期不被使用
Cache-Control: must-revalidate
```

[Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma) 头是`HTTP/1.0`标准中定义的，效果同`Cache-Control: no-cache`相同，但是 HTTP 的响应头没有明确定义这个属性，所以它不能完全替代 HTTP/1.1 中定义的 Cache-control 头。通常用来`向后兼容`基于 HTTP/1.0 的客户端，那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来。建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。

## 新鲜度

理论上，当资源被缓存后，可以永久存储在缓存中。由于缓存空间有限，所以会定期将一些副本删除，这个过程叫`缓存驱逐`。

当服务器上的资源更新了，缓存中对应的资源也应该被`更新`。由于HTTP是C/S模式的协议，服务器更新一个资源时，不能直接通知客户端更新缓存，所以双方必须为该资源约定一个`过期时间`，来判断缓存是`新鲜的`或`陈旧的`。

驱逐算法将`旧`资源换成`新`的，注意，旧资源不会直接被清除或忽略。

当发起一个请求时，缓存检索到已有一个对应的旧资源，则缓存会先将此请求附加一个`If-None-Match`头，然后发给目标服务器，来检查该缓存是否还是新的，若服务器返回了 `304` (Not Modified)（该响应不会有带有实体信息），则表示此缓存是`新的`，这样一来，可以节省一些带宽。若服务器通过`If-None-Match`或`If-Modified-Since`判断后发现`已过期`，那么会带有该资源的`实体内容`返回。

缓存处理过程图示：

![缓存处理过程](https://media.prod.mdn.mozit.cloud/attachments/2016/08/19/13771/2e3dc2278f2aaa83a695e1c1eca98fc0/HTTPStaleness.png ':size=600')

如果请求头含有`Cache-control`（比如，Cache-control: max-age=N），会去`计算`缓存寿命。相应的缓存寿命就是`N`。如果不含该属性，则会查看是否包含 [Expires](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expires) 属性，通过比较 Expires 的值和头里面 Date 属性的值来判断是否缓存还有效。如果 max-age 和 expires 属性都没有，会找头里的 `Last-Modified` 信息。如果有，缓存的寿命就等于头里面 Date 的值减去 Last-Modified 的值除以10。

缓存`失效时间`计算公式：

```
expirationTime = responseTime + freshnessLifetime - currentAge
```

## 改进资源

缓存的资源越多，网站性能就越好。

为了优化缓存，可以设置`较长`的过期时间。对于定期或频繁更新的资源，可以这么设置，但对于长期不更新的资源会有问题，一旦需要更新就很困难。比如引入的 js/css 文件，当它们变动时需要尽早更新。

解决方案（`revving` 技术）：对不频繁更新的文件使用特定的`命名方式`。比如，在 URL 后面（通常是文件名后面）会加上`版本号`、`hash`或`时间戳`。（其实就是被视作一个`全新`的资源，同时设置拥有更长的缓存过期时长）。

## 缓存验证

触发缓存验证：

1. 刷新页面。
2. 响应头含有 `Cache-control: must-revalidate`。
3. 浏览器设置强制验证缓存。

当缓存过期后，需要进行缓存验证或者重新获取资源。只有在服务器返回`强校验器`或者`弱校验器`时才会进行验证。

1. 强校验器：`ETag`响应头。如果请求的响应头里有 ETag，客户端可以在后续的请求的头中带上`If-None-Match`头来验证缓存。
2. 弱校验器：`Last-Modified`响应头。弱是因为它只能精确到一秒。如果响应头里含有 Last-Modified，客户端可以在后续的请求中带上`If-Modified-Since`来验证缓存。

当向服务端发起缓存校验的请求时，服务端会返回 200 ok 表示返回正常的结果或者 304 Not Modified(不返回body)表示浏览器可以使用本地缓存文件。`304`的响应头也可以同时`更新`缓存文档的`过期时间`。

## Vary 响应

[Vary](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary) 响应头，它决定了对于后续的请求头，应该用一个缓存的回复还是向源服务器请求一个新的回复。

使用 vary 头有利于内容服务的`动态多样性`。例如，使用 Vary: User-Agent 头，缓存服务器需要通过UA判断是否使用缓存的页面。如果需要区分`移动端`和`桌面端`的展示内容，利用这种方式就能避免在不同的终端展示错误的布局。

因为移动版和桌面的客户端的请求头中的`User-Agent`不同， 缓存服务器不会错误地把移动端的内容输出到桌面端到用户。

## 强缓存、协商缓存

浏览器缓存策略大致分为两种：`强缓存`和`协商缓存`

1. 浏览器在加载资源时，根据请求头`Cache-control`和`Expires`（Cache-control 优先级更高）判断是否命中强缓存，如果是则直接从缓存读取资源，不会发送请求到服务器。
2. 如果没有命中强缓存，则会发送请求到服务器，通过`Last-Modified`和`ETag`验证资源是否命中协商缓存，如果命中，服务器则响应请求，但不会返回资源数据，依然是从缓存中读取资源。
3. 如果前两种都没命中，直接从服务器加载资源。

`相同点`：如果命中，都是从缓存中加载资源，而不是从服务器。`不同点`：强缓存不发送请求到服务器，而协商缓存会发送请求。

![缓存流程](https://user-images.githubusercontent.com/25027560/38223505-d8ab53da-371d-11e8-9263-79814b6971a5.png ':size=600')

> [MDN HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
