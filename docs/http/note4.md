# HTTP 缓存

通过复用已获取的资源，可以显著提高网站性能，减少等待时间和流量，缓解服务器压力。

缓存是一种保存`资源副本`并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

缓存需要`合理`配置，并不是所有资源都永久不变，对一个资源的缓存应截止到其下一次发生改变（不能缓存过期的资源）。

### 缓存的种类

可大致分为两类：

1. `私有`缓存。只能用于`单独`用户。
2. `共享`缓存。能够被`多个`用户使用。

浏览器缓存（`私有`）拥有用户通过HTTP下载的所有文档。为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余请求。可以提供缓存内容的离线浏览。

代理缓存（`共享`）。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

### 缓存的目标

常见份HTTP缓存只能存储`GET`响应。普通的缓存案例：

1. `GET`请求的成功响应（200）。
2. 永久重定向（301）。
3. 错误响应（404）
4. 不完全的响应（206），只返回局部信息。
5. 除了 GET 请求外，如果匹配到作为一个已被定义的`cache`键名的响应。

### 缓存控制

通过 [Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) 头（HTTP/1.1定义）来定义`缓存策略`。请求头和响应头都支持这个属性。

1. `no-store`：没有缓存。缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。
2. `no-cache`：缓存但重新验证。请求发出时，缓存会将此请求`发到服务器`（该请求会`带有`与本地缓存相关的`验证字段`），服务器端会`验证`请求中所描述的缓存`是否过期`，若未过期（实际就是返回`304`），则缓存才使用本地缓存副本。
3. `public`：公共缓存。响应可以被任何中间人（中间代理、CDN等）缓存。若指定了 public，则一些通常不被中间人缓存的页面（默认是 private），比如带有HTTP验证信息（帐号密码）的页面或某些特定状态码的页面，将会被其缓存。
4. `private`：私有缓存。响应是专用于某单个用户的，中间人不能缓存。
5. `max-age=<seconds>`：过期。表示资源能够被缓存（保持新鲜）的最大时间。相对Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件，通常可以手动设置一定的时长以保证缓存有效，例如图片、css、js等静态资源。
6. `must-revalidate`：验证方式。必须先`验证`它的状态，已过期的缓存将不被使用。

```
不使用缓存
Cache-Control: no-store

缓存，但需要向服务器重新验证是否过期
Cache-Control: no-cache

公共缓存 中间人可缓存
Cache-Control: public

私有缓存（默认） 中间人不能缓存
Cache-Control: private

设置最大过期时间
Cache-Control: max-age=31536000

先验证状态，已过期不被使用
Cache-Control: must-revalidate
```

[Pragma](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma) 头是`HTTP/1.0`标准中定义的，效果同`Cache-Control: no-cache`相同，但是 HTTP 的响应头没有明确定义这个属性，所以它不能完全替代 HTTP/1.1 中定义的 Cache-control 头。通常用来`向后兼容`基于 HTTP/1.0 的客户端，那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来。建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。

### 新鲜度

